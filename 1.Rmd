---
title: "1"
output: html_document
Name : 'Jeongwon Yoo'
date: "2025-11-16"
---

```{r setup, include=FALSE}
library(readr)
library(dplyr)
library(tidymodels)
library(rpart)
library(rpart.plot)
library(smotefamily)
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# data
path = '/Users/jeongwonyoo/Documents/GitHub/introds-project2/Fire_Incidence_Data 2018-2019.csv'
data = read.csv(path)
```

# Data Explore

```{r}
str(data)
```

```{r}
data$Wildfire = factor(
  data$Wildfire,
  levels = c('No', 'Yes'))

train_2018 = subset(data, Year == 2018, select = -Year)
test_2019 = subset(data, Year == 2019, select= -Year)

```

# logistic Regression

```{r}
logit_model = glm(Wildfire ~.,
                  data = train_2018,
                  family = binomial)
summary(logit_model)
```

cutoff 0.5

```{r}
test_2019$prob_yes = predict(logit_model,
                              newdata = test_2019,
                              type = "response")

test_2019$pred = ifelse(test_2019$prob_yes >= 0.5, "Yes", "No")
test_2019$pred = factor(test_2019$pred, levels = c("No","Yes"))
 
cm = table(Predicted = test_2019$pred, Actual= test_2019$Wildfire)
cm
```

cutoff 0.1

```{r}
test_2019$pred = ifelse(test_2019$prob_yes >= 0.1, "Yes", "No")
cm = table(Predicted = test_2019$pred, Actual= test_2019$Wildfire)
cm
```

cutoff 0.2

```{r}
test_2019$pred = ifelse(test_2019$prob_yes >= 0.2, "Yes", "No")
cm = table(Predicted = test_2019$pred, Actual= test_2019$Wildfire)
cm
```

cutoff 0.3

```{r}
test_2019$pred = ifelse(test_2019$prob_yes >= 0.3, "Yes", "No")
cm = table(Predicted = test_2019$pred, Actual= test_2019$Wildfire)
cm
```

I evaluated the logistic regression model, and the outcomes confirmed that the target variable is highly imbalanced. With a cutoff of 0.5, the model predicted all cases as “No.” Even after lowering the cutoff to 0.1, the model only recovered a small number of “Yes” cases, and both precision and recall remained very low. This indicates that logistic regression is not suitable for this dataset.

# Decision Tree

```{r}
tree_model = rpart(Wildfire ~ .,
                    data=train_2018,
                    method = "class",
                    control = rpart.control(
                      minsplit = 50,
                      cp= 0.001))
printcp(tree_model)

rpart.plot(tree_model)
test_2019$tree_pred_class = predict(
  tree_model,
  newdata = test_2019,
  type = "class")

tree_prob = predict(
  tree_model,
  newdata = test_2019,
  type = "prob"
)

test_2019$tree_prob_yes = tree_prob[, "Yes"]

cm_tree <- table(Predicted = test_2019$tree_pred_class,
                 Actual= test_2019$Wildfire)
cm_tree

TP = cm_tree["Yes", "Yes"]
FP = cm_tree["Yes", "No"]
FN = cm_tree["No",  "Yes"]
TN = cm_tree["No",  "No"]

accuracy  = (TP + TN) / sum(cm_tree)
precision = TP / (TP + FP)
recall= TP / (TP + FN)
f1 <- 2 * precision * recall / (precision + recall)
View(tree_prob)
```

SMOTE the data
```{r}
X = train_2018[, setdiff(names(train_2018), c("Wildfire", "YEAR"))]
y = train_2018$Wildfire
smote_out = SMOTE(X, y, K = 5)
train_smote = smote_out$data
colnames(train_smote)[ncol(train_smote)] = "Wildfire"

train_smote$Wildfire = factor(train_smote$Wildfire, levels = c("No", "Yes"))

tree_smote = rpart(Wildfire ~ .,
                   data = train_smote,
                   method = "class",
                   control = rpart.control(minsplit = 50, cp = 0.001))

test_2019$tree_pred_smote = predict(tree_smote,
                                    newdata = test_2019,
                                    type = "class")

cm_smote = table(Predicted = test_2019$tree_pred_smote,
                 Actual= test_2019$Wildfire)
cm_smote

TP_s = cm_smote["Yes", "Yes"]
FP_s = cm_smote["Yes", "No"]
FN_s = cm_smote["No",  "Yes"]
TN_s = cm_smote["No",  "No"]

accuracy_s  = (TP_s + TN_s) / sum(cm_smote)
precision_s = TP_s / (TP_s + FP_s)
recall_s= TP_s / (TP_s + FN_s)
f1_s <- 2 * precision_s * recall_s / (precision_s + recall_s)

accuracy_s
precision_s
recall_s
f1_s

```

smote data has high risk of noise
Pruning tree
```{r}
printcp(tree_smote)

best_cp <- tree_smote$cptable[which.min(tree_smote$cptable[, "xerror"]), "CP"]

best_cp

tree_pruned <- prune(tree_smote, cp = best_cp)

rpart.plot(tree_pruned,type = 1,extra = 1,cex = 0.4,faclen = 3)

test_2019$tree_pred_pruned <- predict(
  tree_pruned,
  newdata = test_2019,
  type = "class"
)

cm_pruned <- table(
  Predicted = test_2019$tree_pred_pruned,
  Actual    = test_2019$Wildfire
)
cm_pruned

TP_p <- cm_pruned["Yes", "Yes"]
FP_p <- cm_pruned["Yes", "No"]
FN_p <- cm_pruned["No",  "Yes"]
TN_p <- cm_pruned["No",  "No"]

accuracy_p  <- (TP + TN) / sum(cm_pruned)
precision_p <- TP / (TP + FP)
recall_p    <- TP / (TP + FN)
f1_p <- 2 * precision_p * recall_p / (precision_p + recall_p)

accuracy_p
precision_p
recall_p
f1_p
```

The pruned decision tree produced the same evaluation metrics as the original SMOTE-trained tree. After pruning, the model has an accuracy of about 77 percent, precision around 5 percent, and recall around 29.5 percent for the “Yes” class. This means pruning simplified the tree structure but did not meaningfully change how the model classifies wildfire events.
The recall is still much higher than the original (non-SMOTE) model, but the false positive count remains large, which keeps the precision low. Overall, SMOTE improved the model’s ability to detect rare “Yes” cases, and pruning helped reduce model complexity without affecting performance.

# logistic regression with SMOTE
```{r}
logit_smote_model <- glm(
  Wildfire ~ .,
  data   = train_smote,
  family = binomial
)

summary(logit_smote_model)

test_2019$prob_yes_smote <- predict(
  logit_smote_model,
  newdata = test_2019,
  type   = "response"
)

eval_cutoff <- function(prob, actual, cutoff) {
  pred <- ifelse(prob >= cutoff, "Yes", "No")
  pred <- factor(pred, levels = c("No", "Yes"))
  
  cm <- table(Predicted = pred, Actual = actual)
  print(cm)
  
  TP_l <- cm["Yes", "Yes"]
  FP_l <- cm["Yes", "No"]
  FN_l <- cm["No",  "Yes"]
  TN_l <- cm["No",  "No"]
  
  accuracy_l  <- (TP_l + TN_l) / sum(cm)
  precision_l <- TP_l / (TP_l + FP_l)
  recall_l    <- TP_l / (TP_l + FN_l)
  f1_l        <- 2 * precision_l * recall_l / (precision_l + recall_l)
  
  out <- c(
    cutoff    = cutoff,
    accuracy  = accuracy_l,
    precision = precision_l,
    recall    = recall_l,
    f1        = f1_l
  )
  
  return(out)
}

cutoffs <- c(0.1, 0.2, 0.3, 0.5)

results_logit_smote <- t(
  sapply(cutoffs, function(c) {
    eval_cutoff(
      prob   = test_2019$prob_yes_smote,
      actual = test_2019$Wildfire,
      cutoff = c
    )
  })
)

results_logit_smote <- as.data.frame(results_logit_smote)
results_logit_smote[] <- lapply(results_logit_smote, as.numeric)

knitr::kable(results_logit_smote, digits = 4)
```