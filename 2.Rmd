---
title: "Project2"
output: html_document
date: "2025-11-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
library(ezids)
library(ggplot2)
library(treemapify)
library(dplyr)
library(gridExtra)
library(e1071)
library(smotefamily)
library(randomForest)
library(e1071)
library(ROCR)
library(corrplot)
```

```{r}

data_clean <- read.csv("Fire_Incidence_Data 2018-2019.csv")

# 1. Clean target variable BEFORE splitting
data_clean$Wildfire <- trimws(data_clean$Wildfire)
data_clean$Wildfire <- factor(data_clean$Wildfire, levels = c("No","Yes"))

table(data_clean$Wildfire)

# 2. Split into train (2018) and test (2019)
train2018 <- subset(data_clean, Year == 2018, select = -Year)
test2019  <- subset(data_clean, Year == 2019, select = -Year)

data_clean$Wildfire <- factor(data_clean$Wildfire, levels = c("No", "Yes"))
str(data_clean$Wildfire)
table(data_clean$Wildfire)

nrow(train2018)
nrow(test2019)

print(colnames(data_clean))
table(data_clean$Wildfire, useNA = "ifany")

table(train2018$Wildfire)

colSums(is.na(train2018[train2018$Wildfire == "Yes", ]))


```
```{r}

num_vars <- train2018[, c("pr","rmax","rmin","sph","srad","tmmn")]

corr_mat <- cor(num_vars, method = "pearson")

corrplot(corr_mat, method = "number", type="upper",
         tl.col="black", title="Correlation Matrix (Climate Variables)")



```



smote
```{r}
# Install if missing
library(smotefamily)
library(dplyr)

# Remove Year
train2018$Year <- NULL

# Convert target to numeric for smotefamily SMOTE
# No = 0, Yes = 1
train2018$Wildfire_num <- ifelse(train2018$Wildfire == "Yes", 1, 0)

# Prepare x and y
x <- train2018 %>% select(-Wildfire, -Wildfire_num)
y <- train2018$Wildfire_num

# Apply SMOTE
set.seed(123)
smote_out <- SMOTE(x, y, K = 5)

# Convert back to dataframe
train_balanced <- smote_out$data

# Rename target
colnames(train_balanced)[ncol(train_balanced)] <- "Wildfire_num"

# Convert numeric target back to factor Yes/No
train_balanced$Wildfire <- factor(
    ifelse(train_balanced$Wildfire_num == 1, "Yes", "No"),
    levels = c("No", "Yes")
)

# Remove the numeric column
train_balanced$Wildfire_num <- NULL

# Check class balance
table(train_balanced$Wildfire)



```
random forest

```{r}


rf_model <- randomForest(
  Wildfire ~ .,
  data = train_balanced,
  ntree = 500,
  importance = TRUE
)

rf_pred <- predict(rf_model, test2019)
rf_cm <- table(Predicted = rf_pred, Actual = test2019$Wildfire)
rf_cm


rf_accuracy <- sum(diag(rf_cm)) / sum(rf_cm)
rf_accuracy

TP <- rf_cm["Yes","Yes"]
FN <- rf_cm["No","Yes"]
FP <- rf_cm["Yes","No"]

rf_precision <- TP / (TP + FP)
rf_recall    <- TP / (TP + FN)
rf_f1        <- 2 * (rf_precision * rf_recall) / (rf_precision + rf_recall)

c(precision = rf_precision, recall = rf_recall, F1 = rf_f1)

rf_prob <- predict(rf_model, test2019, type = "prob")[,"Yes"]

pred <- prediction(rf_prob, test2019$Wildfire)
perf <- performance(pred, "tpr", "fpr")

plot(perf, col="blue", lwd=2, main="Random Forest ROC Curve")
abline(0,1,lty=2,col="gray")

# Numeric importance values
importance(rf_model)

# Plot graph
varImpPlot(rf_model, main = "Random Forest Feature Importance")

```

```{r}
# Convert RF importance to a data frame
imp <- importance(rf_model)

imp_df <- data.frame(
  Feature = rownames(imp),
  Importance = imp[, "MeanDecreaseGini"]   # Change if you prefer MeanDecreaseAccuracy
)

# Plot all 20 features (no top_n needed)
imp_df %>%
  ggplot(aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_col(fill = "lightblue") +
  coord_flip() +
  labs(
    title = "Feature Importance for Wildfire Prediction",
    x = "Feature",
    y = "Mean Decrease in Gini (Variable Importance)"
  ) +
  theme_minimal(base_size = 13)

```

Random Forest + SMOTE
```{r}
# 2) Random Forest on SMOTE balanced data
set.seed(123)

rf_model <- randomForest(
  Wildfire ~ .,
  data = train_balanced,
  ntree = 500,
  importance = TRUE
)

# Predictions
rf_pred <- predict(rf_model, test2019)
rf_cm <- table(Predicted = rf_pred, Actual = test2019$Wildfire)
rf_cm

# Metrics
rf_accuracy <- sum(diag(rf_cm)) / sum(rf_cm)

TP <- rf_cm["Yes", "Yes"]
FN <- rf_cm["No",  "Yes"]
FP <- rf_cm["Yes", "No"]

rf_precision <- TP / (TP + FP)
rf_recall    <- TP / (TP + FN)
rf_f1        <- 2 * (rf_precision * rf_recall) / (rf_precision + rf_recall)

c(accuracy = rf_accuracy,
  precision = rf_precision,
  recall    = rf_recall,
  F1        = rf_f1)

# ROC curve
rf_prob <- predict(rf_model, test2019, type = "prob")[, "Yes"]

pred <- prediction(rf_prob, test2019$Wildfire)
perf <- performance(pred, "tpr", "fpr")

# AUC
auc_perf <- performance(pred, "auc")
rf_auc <- auc_perf@y.values[[1]]
rf_auc


plot(perf, col = "blue", lwd = 2, main = "Random Forest ROC Curve")
abline(0, 1, lty = 2, col = "gray")

# Variable importance
importance(rf_model)
varImpPlot(rf_model, main = "Random Forest Feature Importance")

imp <- importance(rf_model)

imp_df <- data.frame(
  Feature    = rownames(imp),
  Importance = imp[, "MeanDecreaseGini"]
)

imp_df %>%
  ggplot(aes(x = reorder(Feature, Importance), y = Importance)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Feature Importance for Wildfire Prediction ",
    x = "Feature",
    y = "Mean Decrease in Gini"
  ) +
  theme_minimal(base_size = 13)
```

SVM + SMOTE

```{r}
# SVM on SMOTE balanced data
svm_model <- svm(
  Wildfire ~ .,
  data = train_balanced,   # SMOTE data
  kernel = "radial",
  probability = TRUE,
  scale = TRUE
)

# Predictions
svm_pred <- predict(svm_model, test2019)
svm_cm <- table(Predicted = svm_pred, Actual = test2019$Wildfire)
svm_cm

# Accuracy
svm_accuracy <- sum(diag(svm_cm)) / sum(svm_cm)

# Metrics
TP_svm <- svm_cm["Yes", "Yes"]
FN_svm <- svm_cm["No",  "Yes"]
FP_svm <- svm_cm["Yes", "No"]

svm_precision <- TP_svm / (TP_svm + FP_svm)
svm_recall    <- TP_svm / (TP_svm + FN_svm)
svm_f1        <- 2 * (svm_precision * svm_recall) / (svm_precision + svm_recall)
 
c(
  accuracy  = svm_accuracy,
  precision = svm_precision,
  recall    = svm_recall,
  F1        = svm_f1
)

# Probability prediction
svm_prob <- attr(
  predict(svm_model, test2019, probability = TRUE),
  "probabilities"
)[, "Yes"]

# ROCR performance objects
pred_svm <- prediction(svm_prob, test2019$Wildfire)
perf_svm <- performance(pred_svm, "tpr", "fpr")

# Plot ROC curve
plot(perf_svm, col = "red", lwd = 2, main = "SVM ROC Curve")
abline(0, 1, lty = 2, col = "gray")

# Compute AUC
svm_auc <- performance(pred_svm, "auc")@y.values[[1]]
svm_auc
```